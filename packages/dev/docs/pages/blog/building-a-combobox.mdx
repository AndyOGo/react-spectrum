<!-- Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License. -->

import {BlogPostLayout} from '@react-spectrum/docs';
export default BlogPostLayout;

---
keywords: [combobox, accessibility, mobile, react spectrum, react, spectrum, interactions, touch]
description: In this post we take a deeper look into some of the challenges faced when building an accessible and mobile friendly ComboBox.
date: 2020-08-25
author: '[Daniel Lu](https://github.com/LFDanLu)'
---

# Building a ComboBox

## Intro

As of INSERT DATE HERE, React Spectrum ComboBox has been released as an alpha. For those who may be unfamiliar with a combobox, it is an input field that has a popover menu associated with it. The popover menu contains
a list of values within that a user may select as the value for the combobox and is often filtered to display possible matches to the user's current
input text. Finally, there is a button accompanying the input field used for toggling the open state of the popover menu.

While the above may seem rather straight forward, a combobox contains a significant amount of complexity. Focus needs to remain within the input field
regardless of the popup menu's open state so that a user may continue to filter down the list, but virtual focus needs to be displayed so that items
can be highlighted and selected via keyboard commands as well. A combobox's input value will often diverge and converged from its currently selected value based on
the user's interaction and the combobox's configuration. Cross browser and device support adds additional layers of complexity with each of their behavioral quirks and
interaction models.

In this blog post, we'll be covering the challenges we encountered with regards to ComboBox's mobile experience and accessibility.

## Mobile experience

Like many of our other components, ComboBox displays its popover menu items in a tray when rendered on a mobile device or a smaller screen. This allows for a better mobile experience
since the tray can display more items on the screen and grants users a larger hit area to scroll through. To compensate for the fact that the tray covers the majority of the
screen including the ComboBox, we included an input field within the tray so that end users could still type to filter the available items. So far so good. However,
when we tested the ComboBox's tray input on iOS Safari, the tray's bottom half was covered by the onscreen keyboard and we could not scroll the hidden items into view.

It turns out that iOS Safari does not shrink the browser window to accommodate the onscreen keyboard unlike other mobile browsers. Instead, Safari pushes the window upwards and
partially off screen. At the time, we had been relying on `window.innerHeight` to inform us on how tall the tray should be but now we had to find a different way of tracking the available window
space for the tray.

Luckily for us, iOS 13 added support for the VisualViewport API. By querying `window.VisualViewport.height` we could get a reliable measurement of how much vertical space was available on screen. Furthermore, we could track
when the onscreen keyboard was opened or dismissed by listening to the VisualViewport's `resize` event. Leveraging these two allowed us to create a tray that properly adjusts to the presence of iOS onscreen keyboard.
If you'd like to track the visual viewport size in your own app, you can use the `useViewportSize` hook available in the `@react-aria/utils` package.

## Accessibility

To ensure that our ComboBox is accessible, we followed the [WAI-ARIA 1.2 combobox spec](https://www.w3.org/TR/wai-aria-practices-1.2/#combobox). Unfortunately, differences between our implementation and the spec arose
as we built ComboBox and subsequent testing sessions revealed varied support across screen readers. Here are just a couple of the challenges we faced and the solutions we came up with to address them.

### Portals

One significant difference between the WAI-ARIA 1.2 ComboBox spec and our ComboBox implementation was the usage of React Portals for the menu. In the [example](https://www.w3.org/TR/wai-aria-practices-1.2/examples/combobox/combobox-autocomplete-list.html)
provided by the spec, the combobox menu is a sibling to the combobox, allowing for easy focus navigation between the the two elements when using a screenreader. The same couldn't be said for our ComboBox menu since
it is portalled to the end of the document, meaning there could be any number of elements that a screenreader user would have to navigate through just to move from the ComboBox input to the menu itself. Furthermore, we had to figure out
a way to make the ComboBox input and the ComboBox menu the only elements accessible to screen readers while the menu is open so that a screen reader user wouldn't accidentally leave the ComboBox context.

The solution that we came up with was to crawl the DOM and apply `aria-hidden` to every element that wasn't the ComboBox input or menu. To crawl the DOM we used a [TreeWalker](https://developer.mozilla.org/en-US/docs/Web/API/TreeWalker),
setting up a node filter to determine if a node should be left visible, hidden, or skipped in the case where its parent was already hidden. In addition, we watch for any changes in the DOM while the menu is open
via a [MutationObserver](https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver), hiding those new elements if need be. When the menu closes, every node that we modified is reverted back to its previous state.
Check out our `ariaHideOutside` hook in `@react-aria/overlays` if you'd like to learn more.

### Differences in screen readers

Just like browsers, screen readers can be quite varied in behavior and may require deliberate tooling to ensure a consistent degree of functionality.

#### NVDA

Initially, our ComboBox would automatically focus the first item in the menu whenever opened so the user wouldn't have to issue another keypress to begin menu navigation. However, when we tested the ComboBox using NVDA we discovered that
character deletions and text cursor movement in the ComboBox input weren't being announced at all. NVDA would only resume announcing if no menu items were being focused, so we ended up clearing menu item focus on any changes to the input text or
left/right arrow key presses.

#### VoiceOver

VoiceOver as a whole doesn't seem to work very well with `aria-activedescendant`, failing to announce when the focused ComboBox item changed in a variety of situations. In Safari, changes to the `aria-activedescendant` aren't announced
as long as the input is empty. In Chrome, VoiceOver only announces changes to `aria-activedescendant` if `aria-selected="true"` is applied to the focused item. In Firefox, VoiceOver only announces the first item you focused. If the list of options is organized into separate sections,
VoiceOver doesn't announce changes to the focused item for all browsers.

Announcing item focus wasn't the only issue encountered. VoiceOver doesn't announce the number of options currently available in the menu or the current section title, information that an end user would find helpful when navigating the ComboBox menu.
When selecting an option from the menu, an announcement of the item's name is made but the fact that it is now "selected" is omitted.

As a workaround, we made use of [ARIA live-regions](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Live_Regions). When the ComboBox's menu is opened for the first time, we create two visually hidden `aria-live` regions in the DOM with two `div`s, one with `aria-live="polite"` and the other `aria-live="assertive"`
so that we have control over how the message should be announced to the user. Then whenever updates occur in the ComboBox, we can have the screen reader announce custom messages by updating the contents of said `div`s. This allows us to fill in the announcement gaps mentioned previously as well as standardize the
announcement experience over each of the browsers. If you are interested in using this LiveAnnouncer yourself, check out `LiveAnnouncer` in `@react-aria/live`.

## Conclusion

If there is one takeaway, it is that cross browser and device testing is extremely important when building a component. A solution that may work in one browser and device combo may result in a broken experience in another. Browsers, devices, and assistive technologies each have their own behavioral quirks that often are only made apparent
after thorough testing.

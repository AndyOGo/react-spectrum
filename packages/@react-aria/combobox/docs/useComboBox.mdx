<!-- Copyright 2020 Adobe. All rights reserved.
This file is licensed to you under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License. You may obtain a copy
of the License at http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software distributed under
the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
OF ANY KIND, either express or implied. See the License for the specific language
governing permissions and limitations under the License. -->

import {Layout} from '@react-spectrum/docs';
export default Layout;

import docs from 'docs:@react-aria/combobox';
import collectionsDocs from 'docs:@react-types/shared/src/collections.d.ts';
import {FunctionAPI, HeaderInfo, InterfaceType, renderHTMLfromMarkdown, TypeContext, TypeLink} from '@react-spectrum/docs';
import i18nDocs from 'docs:@react-aria/i18n';
import listboxDocs from 'docs:@react-aria/listbox';
import overlaysDocs from 'docs:@react-aria/overlays';
import packageData from '@react-aria/combobox/package.json';
import selectionDocs from 'docs:@react-stately/selection';
import statelyDocs from 'docs:@react-stately/combobox';


```jsx import
import {useComboBox} from '@react-aria/combobox';
```

---
category: Pickers
keywords: [combobox, aria]
---

# useComboBox

<p>{renderHTMLfromMarkdown(docs.exports.useComboBox.description)}</p>

<HeaderInfo
  packageData={packageData}
  componentNames={['useComboBox']} />

## API

<FunctionAPI function={docs.exports.useComboBox} links={docs.links} />

## Features

There is no native element to implement a ComboBox in HTML. `useComboBox` helps achieve accessible ComboBox components that can
be styled as needed.

* Exposed to assistive technology as a ComboBox
* Support for selecting a single option
* Support for disabled options
* Support for sections
* Support for custom user input values
* Labeling support for accessibility
* Required and invalid states exposed to assistive technology via ARIA
* Support for mouse, touch, and keyboard interactions
* Keyboard support for opening the ComboBox menu using the arrow keys, including automatically focusing
  the first or last item accordingly
* Virtual focus management for ComboBox menu option navigation
* VoiceOver announcement enhancements for option focusing, filtering, and selection

## Anatomy

A ComboBox consists of a label, an input which displays the current value, a listbox popup, and a button
used to toggle the listbox popup open state. Users can type within the input to filter the available options
within the listbox popup. The listbox popup may be opened by a variety of input field interactions specified
by the `menuTrigger` prop provided to `useComboBox`, or by clicking or touching the ComboBox trigger button. `useComboBox` handles exposing
the correct ARIA attributes for accessibility for each of the components comprising the ComboBox. It should be combined
with [useListBox](useListBox.html), which handles the implementation of the popup listbox,
and [useButton](useButton.html) which handles the button press handlers returned by `useComboBox`.

`useComboBox` returns props that you should spread onto the appropriate elements:

<TypeContext.Provider value={docs.links}>
  <InterfaceType properties={docs.links[docs.exports.useComboBox.return.id].properties} />
</TypeContext.Provider>

State is managed by the <TypeLink links={statelyDocs.links} type={statelyDocs.exports.useComboBoxState} /> hook from `@react-stately/select`.
The state object should be passed as an option to `useComboBox`.

If the ComboBox does not have a visible label, an `aria-label` or `aria-labelledby` prop must be passed instead to
identify it to assistive technology.

## State management

`useComboBox` requires knowledge of the options in the ComboBox in order to handle keyboard
navigation and other interactions. It does this using the <TypeLink links={collectionsDocs.links} type={collectionsDocs.exports.Collection} />
interface, which is a generic interface to access sequential unique keyed data. You can
implement this interface yourself, e.g. by using a prop to pass a list of item objects,
but <TypeLink links={statelyDocs.links} type={statelyDocs.exports.useComboBoxState} /> from
`@react-stately/combobox` implements a JSX based interface for building collections instead.
See [Collection Components](/react-stately/collections.html) for more information,
and [Collection Interface](/react-stately/Collection.html) for internal details.

In addition, <TypeLink links={statelyDocs.links} type={statelyDocs.exports.useComboBoxState} />
manages the state necessary for single selection and exposes
a <TypeLink links={selectionDocs.links} type={selectionDocs.exports.SelectionManager} />,
which makes use of the collection to provide an interface to update the selection state.
It also holds state to track if the popup is open, if the ComboBox is focused, and the current input value.
For more information about selection, see [Selection](/react-stately/selection.html).

## Example

This example uses an `<input>` element for the ComboBox text input and a `<button>` element for the ComboBox menu trigger. A `<span>`
is included within the `<button>` to display the dropdown arrow icon (hidden from screen readers with `aria-hidden`).
A "contains" filter function is obtained from <TypeLink links={i18nDocs.links} type={i18nDocs.exports.useFilter} /> and is passed to <TypeLink links={statelyDocs.links} type={statelyDocs.exports.useComboBoxState} /> so
that the ComboBox list can be filtered based on the option text and the current ComboBox input text.

The listbox popup uses <TypeLink links={listboxDocs.links} type={listboxDocs.exports.useListBox} />
and <TypeLink links={listboxDocs.links} type={listboxDocs.exports.useOption} /> to render the
list of options. A hidden &lt;<TypeLink links={overlaysDocs.links} type={overlaysDocs.exports.DismissButton} />&gt;
is added at the start and end of the popup to allow screen reader users to dismiss the popup. Note that `shouldUseVirtualFocus` is passed to `useListBox`
and `useOption` so that browser focus remains within the ComboBox `<input>` element even when interacting with the ComboBox menu options.

This example does not do any advanced popover positioning or portaling to escape its visual container.
See [useOverlayTrigger](useOverlayTrigger.html) for an example of how to implement this
using <TypeLink links={overlaysDocs.links} type={overlaysDocs.exports.useOverlayPosition} />.

In addition, see [useListBox](useListBox.html) for examples of sections (option groups), and more complex
options.

```tsx example
import {Item} from '@react-stately/collections';
import {mergeProps} from '@react-aria/utils';
import {useButton} from '@react-aria/button';
import {useComboBoxState} from '@react-stately/combobox'
import {useFilter} from '@react-aria/i18n';
import {useListBox, useOption} from '@react-aria/listbox';
import {useOverlay, DismissButton} from '@react-aria/overlays';

function ComboBox(props) {
  // Get a basic "contains" filter function for input value and option text comparison
  let {contains} = useFilter({sensitivity: 'base'});

  // Create state based on the incoming props and the filter function
  let state = useComboBoxState({...props, defaultFilter: contains});

  // Get props for child elements from useComboBox
  let triggerRef = React.useRef();
  let inputRef = React.useRef();
  let listBoxRef = React.useRef();
  let popoverRef = React.useRef();

  let {buttonProps: triggerProps, inputProps, listBoxProps, labelProps} = useComboBox(
    {
      ...props,
      inputRef,
      buttonRef: triggerRef,
      listBoxRef,
      popoverRef,
      menuTrigger: 'input',
    },
    state
  );

  // Get props for the ComboBox trigger button based on the button props from useComboBox
  let {buttonProps} = useButton(triggerProps, triggerRef);

  return (
    <div style={{position: 'relative', display: 'inline-block'}}>
      <div {...labelProps}>{props.label}</div>
      <input
        {...inputProps}
        ref={inputRef}
        style={{
          borderRight: 0,
          borderBottomRightRadius: 0,
          borderTopRightRadius: 0
        }} />
      <button
        {...buttonProps}
        ref={triggerRef}
        style={{
          height: '21px',
          borderBottomLeftRadius: 0,
          borderTopLeftRadius: 0
        }}>
        <span
          aria-hidden="true"
          style={{paddingLeft: 5}}>
          â–¼
        </span>
      </button>
      {state.isOpen &&
        <ListBoxPopup
          {...listBoxProps}
          // Use virtual focus to get aria-activedescendant tracking and
          // ensure focus doesn't leave the input field
          shouldUseVirtualFocus
          listBoxRef={listBoxRef}
          popoverRef={popoverRef}
          state={state} />
      }
    </div>
  );
}

function ListBoxPopup(props) {
  let {
    popoverRef,
    listBoxRef,
    state,
    shouldUseVirtualFocus,
    ...otherProps
  } = props;

  // Get props for the listbox. Prevent focus moving to listbox via shouldUseVirtualFocus
  let {listBoxProps} = useListBox({
    autoFocus: state.focusStrategy,
    disallowEmptySelection: true,
    shouldUseVirtualFocus,
    ...otherProps
  }, state, listBoxRef);

  // Handle events that should cause the popup to close,
  // e.g. blur, clicking outside, or pressing the escape key.
  let {overlayProps} = useOverlay({
    onClose: () => state.close(),
    shouldCloseOnBlur: true,
    isOpen: state.isOpen,
    isDismissable: true
  }, popoverRef);

  // Add hidden <DismissButton> components at the start and end of the list
  // to allow screen reader users to dismiss the popup easily.
  return (
    <div {...overlayProps} ref={popoverRef}>
      <DismissButton onDismiss={() => state.close()} />
      <ul
        {...mergeProps(listBoxProps, otherProps)}
        ref={listBoxRef}
        style={{
          position: 'absolute',
          width: '100%',
          margin: '4px 0 0 0',
          padding: 0,
          listStyle: 'none',
          border: '1px solid gray',
          background: 'lightgray'
        }}>
        {[...state.collection].map(item => (
          <Option
            shouldUseVirtualFocus
            key={item.key}
            item={item}
            state={state} />
        ))}
      </ul>
      <DismissButton onDismiss={() => state.close()} />
    </div>
  )
}

function Option({item, state, shouldUseVirtualFocus}) {
  let ref = React.useRef();
  let isDisabled = state.disabledKeys.has(item.key);
  let isSelected = state.selectionManager.isSelected(item.key);
  // Track focus via focusedKey state instead of with focus event listeners
  // since focus never leaves the text input in a ComboBox
  let isFocused = state.selectionManager.focusedKey === item.key;

  // Get props for the option element. Prevent options from recieving true focus via shouldUseVirtualFocus.
  let {optionProps} = useOption({
    key: item.key,
    isDisabled,
    isSelected,
    shouldSelectOnPressUp: true,
    shouldFocusOnHover: true,
    shouldUseVirtualFocus
  }, state, ref);

  return (
    <li
      {...optionProps}
      ref={ref}
      style={{
        background: isSelected
          ? 'blueviolet'
          : isFocused
            ? 'gray'
            : 'transparent',
        color: isSelected || isFocused ? 'white' : 'black',
        padding: '2px 5px',
        outline: 'none',
        cursor: 'pointer'
      }}>
      {item.rendered}
    </li>
  );
}

<ComboBox label="Favorite Animal">
  <Item key="red panda">Red Panda</Item>
  <Item key="cat">Cat</Item>
  <Item key="dog">Dog</Item>
  <Item key="aardvark">Aardvark</Item>
  <Item key="kangaroo">Kangaroo</Item>
  <Item key="snake">Snake</Item>
</ComboBox>
```

## Internationalization

`useComboBox` handles some aspects of internationalization automatically.
For example, the item focus, count, and selection VoiceOver announcements are formatted to match the current locale.
You are responsible for localizing all labels and option
content that is passed into the select.

### RTL

In right-to-left languages, the ComboBox should be mirrored. The trigger button should be on the left,
and the input element should be on the right. In addition, the content of ComboBox options should
flip. Ensure that your CSS accounts for this.
